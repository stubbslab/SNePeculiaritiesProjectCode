import numpy as np
from scipy.interpolate import interp1d
from loadSN import loadSN
from AstronomicalParameterArchive import AstronomicalParameterArchive
from CosmologicalParameterArchive import CosmologicalParameterArchive 
from calculateMuForDaDtofTFromz import ResidualMuCalculatorForSpecifiedDaDtofT
from calculateMuForXOfTauFromz import ResidualMuCalculatorForArbitraryXofT

if __name__  == "__main__":

    astro_arch = AstronomicalParameterArchive()
    cosmo_arch = CosmologicalParameterArchive()
    s_to_yr = astro_arch.getSecondToYear() 
    cosmo_archive = CosmologicalParameterArchive()
    age_of_universe = cosmo_archive.getAgeOfUniverse( units = 'yr')[0]
    
    all_sn = loadSN(1, pull_extinctions = 0)
    all_surveys = np.unique([sn['survey'] for sn in all_sn])
    all_zs = [sn['z'] for sn in all_sn]
    all_ts = [sn['t'] for sn in all_sn]
    all_taus = [sn['tau'] for sn in all_sn]
    all_muErrs = [sn['muErr'] for sn in all_sn]
    all_muResids = [sn['muDiff'] for sn in all_sn]
    all_zerodMuResids = [sn['muDiff'] - sn['muDiffWMean'] for sn in all_sn]
    all_surveys = [sn['survey'] for sn in all_sn]
    unique_surveys = np.unique(all_surveys)
    #sorted_zs = sorted(all_zs)
    if t_or_tau.lower() in ['tau','taus']:
        all_lookBacks = [10 ** (-6.0) * tau * s_to_yr for tau in all_taus]
    else:
        all_lookBacks = [10 ** (-6.0) * t * s_to_yr for t in all_ts]
    sn_weights = [1.0 / err ** 2.0 for err in all_muErrs]
    full_mean = sum([sn_weights[i] * all_muResids[i] for i in range(len(sn_weights))]) / (sum(sn_weights))
    all_flatZerodMuResids = [resid - full_mean for resid in all_muResids]
    #sorted_lookBacks = [t_or_tau for _,t_or_tau in sorted(zip(all_zs, all_lookBacks))]
    subtract_individual_means = 1
    sorted_zs, sorted_lookBacks, sorted_muErrs, sorted_resids, sorted_resids_noBySurveyZeroing, sorted_surveys = safeSortOneListByAnother(all_zs, [all_zs, all_lookBacks, all_muErrs, all_zerodMuResids, all_flatZerodMuResids, all_surveys])
    filled_zs = np.linspace(10.0 ** -10.0, max(sorted_zs), 10001)

    canon_mus_filled = ResidualMuCalculatorForSpecifiedDaDtofT(DaDtPerturbationFunction = lambda ts, taus, zs: 0.0 if type(ts) in [float, int] else 0.0 + np.zeros(np.shape(ts)), initial_zs = np.array([0.0] + filled_zs.tolist())).getMus()
    
    canon_mus_filled_test = ResidualMuCalculatorForArbitraryXofT(XOfFunction = lambda ts, taus, zs: 1.0 if type(ts) in [float, int, np.float64] else [1.0 for t in ts], initial_zs = np.array([0.0] + filled_zs.tolist())).getMus()
    plt.scatter(initial_zs, np.array(canon_mus_filled_test) - np.array(canon_mus_filled))
    plt.show() 

    target_dir = '/Users/sasha/Documents/Harvard/physics/stubbs/SNIsotropyProject/'
    file_of_resid_da_of_t = 'my_approx_of_t_vs_aDot_of_Ringermacher_1.csv'
    rows = [] 
    with open(target_dir + file_of_resid_da_of_t) as csv_file:
        csv_reader = csv.DictReader(csv_file)
        for row in csv_reader: 
            rows = rows + [row['x'], row['Curve1']] 

    interp_ts = [row[0] for row in rows]
    interp_da_resids = [row[1] for row in rows]

    da_of_t_interp = interp1d(interp_ts, interp_da_resids)
