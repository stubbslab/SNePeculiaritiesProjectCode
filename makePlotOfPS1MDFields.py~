import numpy as np
import scipy.optimize as optimize 
import cantrips as c 
import math
from PanStars1Archive import PanStars1Archive
from loadSN import loadSN
from binData import binData 
import matplotlib.pyplot as plt
from DirectoryArchive import DirectoryArchive
from FitStorer import FitStorer
from SDSSArchive import SDSSArchive
from checkIfInCyclicRange import checkIfInCyclicRange
from AstronomicalParameterArchive import AstronomicalParameterArchive
from matplotlib.patches import Rectangle


def plot_mwd(RA, Dec, ax, org=0,title='Aitoff Sky', projection='aitoff'):
    ''' RA, Dec are arrays of the same length.
    RA takes values in [0,360), Dec in [-90,90],
    which represent angles in degrees.
    org is the origin of the plot, 0 or a multiple of 30 degrees in [0,360).
    title is the title of the figure.
    projection is the kind of projection: 'mollweide', 'aitoff', 'hammer', 'lambert'
    '''
    x = np.remainder(RA+360-org,360) # shift RA values
    ind = x>180
    x[ind] -=360    # scale conversion to [-180, 180]
    x=-x    # reverse the scale: East to the left
    tick_labels = np.array([150, 120, 90, 60, 30, 0, 330, 300, 270, 240, 210])
    tick_labels = np.remainder(tick_labels+360+org,360)
    #fig = plt.figure(figsize=(10, 5))
    #ax = fig.add_subplot(111, projection=projection, axisbg ='LightCyan')
    ax.scatter(np.radians(x),np.radians(Dec))  # convert degrees to radians
    ax.set_xticklabels(tick_labels)     # we add the scale on the x axis
    ax.set_title(title)
    ax.title.set_fontsize(15)
    ax.set_xlabel("RA")
    ax.xaxis.label.set_fontsize(12)
    ax.set_ylabel("Dec")
    ax.yaxis.label.set_fontsize(12)
    ax.grid(True)

def makePlotOfPS1MDFields(data_set, n_bins = 20, bin_scheme = 'bin_size', save = 1, show = 0, surveys_to_display = ['PS1MD', 'SDSS','SNLS'], fit_information = {'funct':'none'}, show_fit_label = 1, z_range = [-0.1, 1.1], res_range = [-0.8, 0.8], binned_res_range = [-0.4, 0.4], archive_to_use = 'PS1MD' , pull_extinctions = 1, figsize = [16.0, 8.0], separate_fields_by_plot = 0, n_randomizations = 0):

    dir_archive = DirectoryArchive()
    plot_dir = dir_archive.getPlotDirectory()
    astro_arch = AstronomicalParameterArchive()
    deg_to_rad = astro_arch.getDegToRad() 
    
    
    PSArch = PanStars1Archive()
    SDSSArch = SDSSArchive()

    if archive_to_use.lower() == 'sdss':
        archive = SDSSArch
    else:
        archive = PSArch
    fields = archive.fields 

    all_sns = loadSN(1, ['all'], pull_extinctions = pull_extinctions)
    if surveys_to_display in ['all','All','ALL']:
        surveys_to_display = [sn['survey'] for sn in all_sns]
        surveys_to_display = np.unique(surveys_to_display).tolist()
    print ('surveys_to_display = ' + str(surveys_to_display ) )
    sn_by_survey = [[sn for sn in all_sns if sn['survey'] == survey] for survey in surveys_to_display if len([sn for sn in all_sns if sn['survey'] == survey]) > 0]
    #print ('sn_by_survey = '  +str(sn_by_survey))
    colors = [sn_set[0]['color'] for sn_set in sn_by_survey] 

    sn_in_survey_by_field = []

    for sn_set in sn_by_survey:
        sn_by_field = {}
        for key in fields:
            field = fields[key] 
            #sn_by_field[key] = [sn for sn in sn_set if (sn['RA']>field[0] and sn['RA'] < field[1] and sn['Dec'] > field[2] and sn['Dec'] < field[3] )]
            sn_by_field[key] = [sn for sn in sn_set if (sn['RA']>field[0] and sn['RA'] < field[1] and sn['Dec'] > field[2] and sn['Dec'] < field[3] )] 
        sn_in_survey_by_field = sn_in_survey_by_field + [sn_by_field]

    fitters = [ [FitStorer(fit_information) for survey in surveys_to_display ] for field in fields]

    fit_funct = lambda zs, A, mean, sig, shift: A * np.exp(-(mean - zs) ** 2.0 / (2.0 * sig ** 2.0)) + shift
    initial_guess = [0.0, 0.5, 1.0, 0.0]
    maxfev = 10000
    n_zs_to_display_fit = 1001


    n_fields = len(fields)
    fig_side = 0 
    while fig_side * 4 - 4 < n_fields:
        fig_side = fig_side + 1
        
    fig = plt.figure(constrained_layout=True, figsize = figsize)
    if not(separate_fields_by_plot): 
        gs = fig.add_gridspec(fig_side, fig_side)
        plot_indeces = [[fig_side - 1, i] for i in range(fig_side)] + [[0, i] for i in range(fig_side)] + c.flattenListOfLists( [[[i, 0], [i, fig_side - 1]] for i in range(1, fig_side-1)] ) 
        for plot_index in plot_indeces:
            fig.add_subplot(gs[plot_index[0], plot_index[1]])
        sky_plot = fig.add_subplot(gs[1:fig_side-1, 1:fig_side-1], projection="aitoff")
        sky_plot.grid(True)
        sky_plot.set_xlabel('R.A.')
        sky_plot.set_ylabel('Decl.')
        tick_labels = np.array([150, 120, 90, 60, 30, 0, 330, 300, 270, 240, 210])
        tick_labels = np.remainder(tick_labels+360+0,360)
        #fig = plt.figure(figsize=(10, 5))
        #ax = fig.add_subplot(111, projection=projection, axisbg ='LightCyan')
        sky_plot.set_xticklabels(tick_labels)     # we add the scale on the x axis
        plots_for_legend = [0 for  sn_in_survey in sn_by_survey]
        for i in range(len(plots_for_legend)):
            sn_in_survey = sn_by_survey[i]
            RA = np.array([(sn['RA']) for sn in sn_in_survey]) 
            Dec = [(sn['Dec']) for sn in sn_in_survey]
            x = np.remainder(RA+360-0,360) # shift RA values
            ind = x>180
            x[ind] -=360    # scale conversion to [-180, 180]
            x=-x    # reverse the scale: East to the left
            plots_for_legend[i] = sky_plot.scatter(np.radians(x), np.radians(Dec) , color = [sn['color']  for sn in sn_in_survey], marker = 'o', s = 2.0 )
        legend_plot_index = plot_indeces[-1]
        ax = fig.add_subplot(gs[legend_plot_index[0], legend_plot_index[1]])
        ax.legend(plots_for_legend, surveys_to_display, ncol = 3, fontsize = 8)
   
    for field_num in range(n_fields):
        field = fields[field_num]
        field_str = 'f' + str(field_num)
        if not(separate_fields_by_plot):
            plot_index = plot_indeces[field_num] 
            ax = fig.add_subplot(gs[plot_index[0], plot_index[1]])
            rect_coords1 =[ -(field[1] if field[1] < 180.0 else field[1] - 360), field[2]]
            rect_coords2 =[ -(field[0] if field[0] < 180.0 else field[0] - 360) - rect_coords1[0] , field[3] - field[2]]
            field_rect = Rectangle([rect_coord * deg_to_rad for rect_coord in rect_coords1], *[rect_coord * deg_to_rad for rect_coord in rect_coords2], edgecolor='black', facecolor='black', alpha = 0.25)
            sky_plot.add_patch(field_rect)
            sky_plot.text((rect_coords1[0] + rect_coords2[0]) * deg_to_rad, (rect_coords1[1] + rect_coords2[1]) * deg_to_rad, field_str)
        else:
            fig, ax = plt.subplots(1, sharex = True, figsize = figsize)
        print ('Displaying field number ' + str(field_num))
        survey_plots = []
        fitted_plots = []
        fit_position_index = 0
        min_z = np.inf
        max_z = -np.inf
        min_mu = np.inf
        max_mu = -np.inf
        all_zs = []
        all_dls = [] 
        all_resids = []
        all_errs = [] 
        for i in range(len(surveys_to_display)):
            sns_in_field_in_survey = sn_in_survey_by_field[i][field_num]
            zs = [sn['z'] for sn in sns_in_field_in_survey]
            dls = [sn['dl'] for sn in sns_in_field_in_survey]
            rs = [dls[j] / (1.0 + zs[j]) for j in range(len(zs))] 
            all_zs = all_zs + zs 
            muDiffs = [sn['muDiff'] - sn['muDiffWMean'] for sn in sns_in_field_in_survey]
            all_resids = all_resids + muDiffs 
            muErrs = [sn['muErr'] for sn in sn_in_survey_by_field[i][field_num]]
            all_errs = all_errs + muErrs 
            if len(zs) > 0:
                min_z = min(min_z, min(zs))
                max_z = max(max_z, max(zs))
            if len(muDiffs): 
                min_mu = min(min_mu, np.min(np.array(muDiffs) + np.array(muErrs)))
                max_mu = max(max_mu, np.max(np.array(muDiffs) + np.array(muErrs))) 
            color = colors[i]
            survey = surveys_to_display[i]
            
            if len(zs) > 0:
                survey_plots = survey_plots + [ax.scatter(zs, muDiffs, c = color) ]
                ax.errorbar(zs, muDiffs, yerr = muErrs, ecolor = color, fmt = 'none')
            else:
                survey_plots = survey_plots + [ax.scatter([],[])] 
            

            #if len(sns_in_field_in_survey) > 0:
            #    z_bin_centers, binned_Sn_data = binData(zs, muDiffs, y_errs = muErrs, n_bins = n_bins, bin_scheme = bin_scheme)
        
            #    axarr[1].scatter(z_bin_centers, binned_Sn_data[0], c = color) 
            #    axarr[1].errorbar(z_bin_centers, binned_Sn_data[0], yerr = binned_Sn_data[1], fmt = None, ecolor = color)
            if fitters[field_num][i].getDimension() == 1 and len(zs) > 2:
                print ('Doing fit.')
                fitters[field_num][i].generateFit(zs, muDiffs, muErrs)
                #print ('For survey ' + surveys_to_display[i] + ', fit params are: ')
                #print (fitters[field_num][i].fit_params)
            #    #print [ [[ sn['z'] for sn in sns if sn['survey'] == surveys_to_display[i] ], fitters[i].getFitValues([ sn['z'] for sn in sns if sn['survey'] == surveys_to_display[i] ])] for i in range(len(surveys_to_display)) ]
                z_step = 0.001
                extra_points_for_fit = np.arange(z_range[0],z_range[1], z_step).tolist()
                fitted_plots = fitted_plots + [ ax.plot( sorted(zs + extra_points_for_fit ), fitters[field_num][i].getFitValues(sorted(zs + extra_points_for_fit)), c =color ) ]
                if show_fit_label:
                    fit_string = fitters[field_num][i].fit_string
                    #print ('Showing text: ' + fit_string)
                    ax.text(0.0,-0.5 + 0.1 * (fit_position_index) ,fit_string, color = color)
                    fit_position_index = fit_position_index + 1
        
        if len(all_zs) > len(initial_guess) + 2:
            try: 
                fit_res = optimize.curve_fit(fit_funct,all_zs, all_resids, p0 = initial_guess, sigma=all_errs, maxfev = maxfev)
                funct_fit = fit_res[0]
            except RuntimeError:
                print("Curve_fit failed!.  Plotting initial guess. ")
                funct_fit = np.array(initial_guess) 
            zs_to_plot = np.linspace(min(all_zs), max(all_zs), n_zs_to_display_fit)
            true_fit_resids = fit_funct(all_zs, *funct_fit)
            null_dof = len(all_zs) - 1 
            dof = len(all_zs) - (len(initial_guess) + 1)
            null_rchisqr = np.sum(np.array((( all_resids) / np.array(all_errs)) ** 2.0)) / null_dof

            true_fit_rchisqr = np.sum(np.array(((true_fit_resids - all_resids) / np.array(all_errs)) ** 2.0)) / dof
            
            plt.plot(zs_to_plot, fit_funct(zs_to_plot, *funct_fit), c ='k')
            rand_rchiSqrs = [np.nan for i in range(n_randomizations)]
            n_rand_done = 0
            while n_rand_done <  n_randomizations:
                if (n_rand_done % 500 == 0 and n_rand_done > 0): print ('Working on randomization ' + str(n_rand_done)) 
                rand_resid_indeces = list(range(len(all_resids))) 
                np.random.shuffle(rand_resid_indeces)
                rand_resids = [all_resids[index] for index in rand_resid_indeces]
                rand_errs = [all_errs[index] for index in rand_resid_indeces]
                #rand_resids = np.random.normal([0.0 for resid in all_resids], all_errs)
                #print ('rand_resids = ' +str(rand_resids)) 
                try: 
                    rand_fit_res = optimize.curve_fit(fit_funct, all_zs, rand_resids, p0 = initial_guess, sigma=rand_errs, maxfev = maxfev)
                    rand_funct_fit = rand_fit_res[0]
                    rand_fit_resids = fit_funct(all_zs, *rand_funct_fit)
                    #null_rand_rchisqr = np.sum(np.array(((rand_resids) / np.array(rand_errs)) ** 2.0)) / null_dof
                    #print ('null_rand_rchisqr = ' + str(null_rand_rchisqr)) 
                    rand_fit_rchisqr = np.sum(np.array(((rand_fit_resids - rand_resids) / np.array(rand_errs)) ** 2.0)) / dof
                    rand_rchiSqrs[n_rand_done] = rand_fit_rchisqr
                    n_rand_done = n_rand_done + 1 
                except RuntimeError:
                    n_rand_done = n_rand_done 
                    #print("Curve_fit to randomized data failed!. ")
        if len(all_zs) > 0:
            if n_randomizations < 1 or len(all_zs) <= len(initial_guess) + 2:
                label_str = field_str
            else:
                label_str = field_str + ': ' + str(c.round_to_n(len([rand_rchiSqr for rand_rchiSqr in rand_rchiSqrs if rand_rchiSqr < true_fit_rchisqr]) / n_randomizations * 100, 3)) + '% chance randomized data have better fit.' r'$\chi^2_{\nu}$=' + str(c.round_to_n(true_fit_rchisqr, 5)) 
            ax.text(0.5, 0.9, label_str,  horizontalalignment='center', transform=ax.transAxes, fontsize = 7)
            
            #print ('[null_rchisqr, true_fit_rchisqr, np.mean(rand_rchiSqrs), np.std(rand_rchiSqrs)] = ' + str([null_rchisqr, true_fit_rchisqr, np.mean(rand_rchiSqrs), np.std(rand_rchiSqrs)]))
            print (str(len([rand_rchiSqr for rand_rchiSqr in rand_rchiSqrs if rand_rchiSqr < true_fit_rchisqr])) + ' of ' + str(n_randomizations) + ' randomizations can be better fit than the the true data.') 
                
            
        #ax.set_xlim(z_range[0], z_range[1])
        #axarr[1].set_xlim(z_range[0], z_range[1])

        ax.set_ylim(res_range[0], res_range[1])
        #axarr[1].set_ylim(binned_res_range[0], binned_res_range[1])

        if separate_fields_by_plot or plot_index[0] == fig_side - 1:
            ax.set_xlabel('z')
        #axarr[1].set_ylabel('Binned mu residual')
        if separate_fields_by_plot or plot_index[1] == 0:
            ax.set_ylabel(r'$\Delta \mu$')

        #ax.set_xticks([-0.1,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1])

        plt.suptitle(r'$\Delta \mu$ of Pan Stars 1 medium-deep fields' ) 

        #print ('len(survey_plots) = ' + str(len(survey_plots)))
        #plt.legend(survey_plots, surveys_to_display, loc = 'upper left', prop = {'size':8})

        if separate_fields_by_plot:
            if save: plt.savefig(plot_dir + 'SN_residuals_v_z_PS1MD_field' + str(field) + '_bin_' + bin_scheme + str(n_bins) + '_fit_' + fit_information['funct'] + '.pdf')
            if show: plt.show()
    
    if not(separate_fields_by_plot):
        if save: plt.savefig(plot_dir + 'SN_residuals_v_z_PS1MD_fields_bin_' + bin_scheme + str(n_bins) + '_fit_' + fit_information['funct'] + '.pdf')
        if show: plt.show() 
    plt.close('all') 
